<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.timbre documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Timbre 2.0.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="taoensso.timbre.html"><span>taoensso.timbre</span></a></li><li><a href="taoensso.timbre.frequencies.html"><span>taoensso.timbre.frequencies</span></a></li><li><a href="taoensso.timbre.profiling.html"><span>taoensso.timbre.profiling</span></a></li><li><a href="taoensso.timbre.utils.html"><span>taoensso.timbre.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="taoensso.timbre.html#var-appenders-juxt-cache"><span>appenders-juxt-cache</span></a></li><li><a href="taoensso.timbre.html#var-config"><span>config</span></a></li><li><a href="taoensso.timbre.html#var-debug"><span>debug</span></a></li><li><a href="taoensso.timbre.html#var-debugf"><span>debugf</span></a></li><li><a href="taoensso.timbre.html#var-error"><span>error</span></a></li><li><a href="taoensso.timbre.html#var-errorf"><span>errorf</span></a></li><li><a href="taoensso.timbre.html#var-fatal"><span>fatal</span></a></li><li><a href="taoensso.timbre.html#var-fatalf"><span>fatalf</span></a></li><li><a href="taoensso.timbre.html#var-info"><span>info</span></a></li><li><a href="taoensso.timbre.html#var-infof"><span>infof</span></a></li><li><a href="taoensso.timbre.html#var-log"><span>log</span></a></li><li><a href="taoensso.timbre.html#var-log*"><span>log*</span></a></li><li><a href="taoensso.timbre.html#var-logf"><span>logf</span></a></li><li><a href="taoensso.timbre.html#var-logging-enabled%3F"><span>logging-enabled?</span></a></li><li><a href="taoensso.timbre.html#var-logp"><span>logp</span></a></li><li><a href="taoensso.timbre.html#var-ns-filter-cache"><span>ns-filter-cache</span></a></li><li><a href="taoensso.timbre.html#var-report"><span>report</span></a></li><li><a href="taoensso.timbre.html#var-reportf"><span>reportf</span></a></li><li><a href="taoensso.timbre.html#var-spy"><span>spy</span></a></li><li><a href="taoensso.timbre.html#var-str-println"><span>str-println</span></a></li><li><a href="taoensso.timbre.html#var-trace"><span>trace</span></a></li><li><a href="taoensso.timbre.html#var-tracef"><span>tracef</span></a></li><li><a href="taoensso.timbre.html#var-warn"><span>warn</span></a></li><li><a href="taoensso.timbre.html#var-warnf"><span>warnf</span></a></li><li><a href="taoensso.timbre.html#var-with-default-outs"><span>with-default-outs</span></a></li><li><a href="taoensso.timbre.html#var-with-err-as-out"><span>with-err-as-out</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>taoensso.timbre documentation</h2><pre class="doc">Simple, flexible, all-Clojure logging. No XML!
</pre><div class="public" id="var-appenders-juxt-cache"><h3>appenders-juxt-cache</h3><div class="usage"></div><pre class="doc">Per-level, combined level-relevant appender-fns to allow for fast runtime
appender-fn dispatch:
{:level (wrapped-juxt wrapped-appender-fn wrapped-appender-fn ...) or nil
  ...}</pre></div><div class="public" id="var-config"><h3>config</h3><div class="usage"></div><pre class="doc">This map atom controls everything about the way Timbre operates.

  APPENDERS
    An appender is a map with keys:
      :doc, :min-level, :enabled?, :async?, :limit-per-msecs, :fn

    An appender's fn takes a single map argument with keys:
      :level, :throwable
      :message,        ; Stringified logging macro args, or nil
      :args,           ; Raw logging macro args (`info`, etc.)
      :ap-config       ; `shared-appender-config`
      :prefix          ; Output of `prefix-fn`
      :profiling-stats ; From `profile` macro
      And also: :instant, :timestamp, :hostname, :ns, :error?

  MIDDLEWARE
    Middleware are fns (applied right-to-left) that transform the map argument
    dispatched to appender fns. If any middleware returns nil, no dispatching
    will occur (i.e. the event will be filtered).

See source code for examples. See `set-config!`, `merge-config!`, `set-level!`
for convenient config editing.</pre></div><div class="public" id="var-debug"><h3>debug</h3><h4 class="macro">macro</h4><div class="usage"><code>(debug &amp; message)</code><code>(debug throwable &amp; message)</code></div><pre class="doc">Log given arguments at :debug level using print-style args.
</pre></div><div class="public" id="var-debugf"><h3>debugf</h3><h4 class="macro">macro</h4><div class="usage"><code>(debugf fmt &amp; fmt-args)</code><code>(debugf throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :debug level using format-style args.
</pre></div><div class="public" id="var-error"><h3>error</h3><h4 class="macro">macro</h4><div class="usage"><code>(error &amp; message)</code><code>(error throwable &amp; message)</code></div><pre class="doc">Log given arguments at :error level using print-style args.
</pre></div><div class="public" id="var-errorf"><h3>errorf</h3><h4 class="macro">macro</h4><div class="usage"><code>(errorf fmt &amp; fmt-args)</code><code>(errorf throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :error level using format-style args.
</pre></div><div class="public" id="var-fatal"><h3>fatal</h3><h4 class="macro">macro</h4><div class="usage"><code>(fatal &amp; message)</code><code>(fatal throwable &amp; message)</code></div><pre class="doc">Log given arguments at :fatal level using print-style args.
</pre></div><div class="public" id="var-fatalf"><h3>fatalf</h3><h4 class="macro">macro</h4><div class="usage"><code>(fatalf fmt &amp; fmt-args)</code><code>(fatalf throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :fatal level using format-style args.
</pre></div><div class="public" id="var-info"><h3>info</h3><h4 class="macro">macro</h4><div class="usage"><code>(info &amp; message)</code><code>(info throwable &amp; message)</code></div><pre class="doc">Log given arguments at :info level using print-style args.
</pre></div><div class="public" id="var-infof"><h3>infof</h3><h4 class="macro">macro</h4><div class="usage"><code>(infof fmt &amp; fmt-args)</code><code>(infof throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :info level using format-style args.
</pre></div><div class="public" id="var-log"><h3>log</h3><h4 class="macro">macro</h4><div class="usage"><code>(log level &amp; args)</code><code>(log level throwable &amp; args)</code></div><pre class="doc">When logging is enabled, actually logs given arguments with level-relevant
appender-fns.</pre></div><div class="public" id="var-log*"><h3>log*</h3><h4 class="macro">macro</h4><div class="usage"><code>(log* base-appender-args level log-vargs ns throwable message juxt-fn)</code><code>(log* base-appender-args level log-args message-fn)</code></div><pre class="doc">Implementation detail - subject to change..
Prepares given arguments for, and then dispatches to all level-relevant
appender-fns. </pre></div><div class="public" id="var-logf"><h3>logf</h3><h4 class="macro">macro</h4><div class="usage"><code>(logf level fmt &amp; fmt-args)</code><code>(logf level throwable fmt &amp; fmt-args)</code></div><pre class="doc">When logging is enabled, actually logs given arguments with level-relevant
appender-fns using format-style :message.</pre></div><div class="public" id="var-logging-enabled%3F"><h3>logging-enabled?</h3><div class="usage"><code>(logging-enabled? level)</code></div><pre class="doc">Returns true when current logging level is sufficient and current namespace
is unfiltered.</pre></div><div class="public" id="var-logp"><h3>logp</h3><h4 class="macro">macro</h4><div class="usage"><code>(logp level &amp; message)</code><code>(logp level throwable &amp; message)</code></div><pre class="doc">When logging is enabled, actually logs given arguments with level-relevant
appender-fns using print-style :message.</pre></div><div class="public" id="var-ns-filter-cache"><h3>ns-filter-cache</h3><div class="usage"></div><pre class="doc">@ns-filter-cache =&gt; (fn relevant-ns? [ns] ...)
</pre></div><div class="public" id="var-report"><h3>report</h3><h4 class="macro">macro</h4><div class="usage"><code>(report &amp; message)</code><code>(report throwable &amp; message)</code></div><pre class="doc">Log given arguments at :report level using print-style args.
</pre></div><div class="public" id="var-reportf"><h3>reportf</h3><h4 class="macro">macro</h4><div class="usage"><code>(reportf fmt &amp; fmt-args)</code><code>(reportf throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :report level using format-style args.
</pre></div><div class="public" id="var-spy"><h3>spy</h3><h4 class="macro">macro</h4><div class="usage"><code>(spy expr)</code><code>(spy level expr)</code><code>(spy level name expr)</code></div><pre class="doc">Evaluates named expression and logs its result. Always returns the result.
Defaults to :debug logging level and unevaluated expression as name.</pre></div><div class="public" id="var-str-println"><h3>str-println</h3><div class="usage"><code>(str-println &amp; xs)</code></div><pre class="doc">Like `println` but prints all objects to output stream as a single
atomic string. This is faster and avoids interleaving race conditions.</pre></div><div class="public" id="var-trace"><h3>trace</h3><h4 class="macro">macro</h4><div class="usage"><code>(trace &amp; message)</code><code>(trace throwable &amp; message)</code></div><pre class="doc">Log given arguments at :trace level using print-style args.
</pre></div><div class="public" id="var-tracef"><h3>tracef</h3><h4 class="macro">macro</h4><div class="usage"><code>(tracef fmt &amp; fmt-args)</code><code>(tracef throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :trace level using format-style args.
</pre></div><div class="public" id="var-warn"><h3>warn</h3><h4 class="macro">macro</h4><div class="usage"><code>(warn &amp; message)</code><code>(warn throwable &amp; message)</code></div><pre class="doc">Log given arguments at :warn level using print-style args.
</pre></div><div class="public" id="var-warnf"><h3>warnf</h3><h4 class="macro">macro</h4><div class="usage"><code>(warnf fmt &amp; fmt-args)</code><code>(warnf throwable fmt &amp; fmt-args)</code></div><pre class="doc">Log given arguments at :warn level using format-style args.
</pre></div><div class="public" id="var-with-default-outs"><h3>with-default-outs</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-default-outs &amp; body)</code></div><pre class="doc">Evaluates body with Clojure's default *out* and *err* bindings.
</pre></div><div class="public" id="var-with-err-as-out"><h3>with-err-as-out</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-err-as-out &amp; body)</code></div><pre class="doc">Evaluates body with *err* bound to *out*.
</pre></div></div></body></html>